#!/usr/bin/env ruby

require 'unobservable'

# movement tick = the time where all the blocks move down.
#
# position is an int coord used for the grid
# location is an int coord used for the screen or fine tuned location on the board.
# i.e. 'location' would say exactly where in a grid square the avatar is location

Coord = Struct.new(:x, :y)

class Cube

  include Unobservable::Support

  # knows how to draw itself.
  # knows its position on the board(grid)
  # moves down each tick
  # will crush the avatar if it lands on him
  # can be destroyd
  # also tracks the list of currently active cubes

  ALL = []

  WIDTH = 20

  attr_event :changed
  attr_accessor :position

  def initialize(position)
    Clock.machine_tick.register :movement_tick
    ALL.push(self)
    @position = position
  end

  def movement_tick

    # move down one square
    # kill player if landed upon
    # emit :changed

    @position.y += 1
    raise_event :changed

    if off_board?
      delete
    end

    if avatar.collides?(self)
      avatar.kill
    end
  end

  def destroy
    # destroyed by a bomb
    delete
  end

  def delete
    # no longer needed in the game.
    #
    # no longer draws itself
    # remove itself from any lists of cubes

    ALL.remove(self)

    raise_event :changed
  end

end

class GreyCube < Cube

  # when it falls off the board, ends game

  def movement_tick
    if off_board?
      puts "missed a grey cube"
      Game.close
    end

    super
  end

end

class BlackCube < Cube

  # when destroyed, ends game

  def destroy
    puts "destroyed a black cube"
    Game.close
  end

end

class Avatar

  # knows how to draw itself
  # has a float board position
  # when destroyed, ends game.
  # listens to player for movement commands

  include Unobservable::Support

  attr_event :changed

  def initialize
    Player.move.register(:move)
    @location = Coord.new(0,0)
  end

  def position
    position_from_location(@location)
  end

  def position_from_location
    # convert and return float coord to grid coord

    Coord.new(location.x / Cube.WIDTH, location.y / Cube.WIDTH )
  end

  def move(x,y)
    # move to position specified
    # unless there is a block in the way
    # or it would be off the map
    #
    new_location = Coord.new(x,y)

    if not board.coord_within?(new_location)
      # blocked by the edge
    end

    if Cube.ALL.any? { |cube| cube.position == new_location }
      # blocked by a cube
    end

    @location = new_location

    raise_event :changed
  end

  def kill
    puts "avatar killed"
    Game.close
  end

end

class Board

  WIDTH = 6
  HEIGHT = 20

  # has a size.
  # knows how to draw itself.
  # doesn't emit any events or listen to any

end

class Bomb

  # knows how to draw itself.
  # also tracks the list of currently active bombs

  include Unobservable::Support

  ALL = []

  attr_event :changed

  def initialize(position)
    ALL.push(self)
    @position = position
  end

  def delete
    ALL.remove(self)
    raise_event :changed
  end

end

class BigBomb < Bomb

  # waits to player for bomb activation
  # on activate
  #  will destroy all nearby cubes.
  #  will destroy the avatar if nearby

  def activate
    each_nearby_position do |coord|

      # destroy all nearby cubes
      Cube.ALL.each do |cube|
        if cube.position == coord
          cube.destroy
        end
      end

      # destroy avatar if nearby
      if avatar.position == coord
        avatar.kill
      end
    end

    delete
    raise_event :changed
  end

  def each_nearby_position
    positions = []
    (-1..1).each do |x_modifier|
      (-1..1).each do |y_modifier|
        coord = Coord.new(@position.x + x_modifier, @position.y + y_modifier)
        if board.coord_within?(coord)
          yield coord
        end
      end
    end
  end


end

class PuzzleGenerator

=begin
  builds a puzzle from a solution backwards

  1. starting with a grid, the width of the playboard, but only a few rows in height.
  2. drop a square of 9 cubes, as if unexploding a bomb.
      the placement of the 9 cubes doesn't have to lie completely within this grid.
      cubes falling outside of the grid will just be forgotten.
  3. do this several times in random places, within that grid.

  the number of times we cycled step 3 becomes the "Par" of bombs needed to complete this level.
=end

end

class Player # (input)

  emits input events
    activate (bomb)
      bomb ont he top of the stack
    move (with a vector)
    end game (escape)

  def initialize
    setup to activate the next bomb on "activate"
  end

end

class Screen

  knows how to draw the whole game.
  owns and manages he window

  listens to everything, and anything that changes, it redraws
    but no faster than a certain speed.
    has ot listen to dynamic objects too or changes.

  def draw

    draw board
    draw bombs
    draw cubes
    draw avatar

    or draw everythiugn from bottom up, back forward.
    or leave it up to opengl, and just create a scenegraph

  end

end

class Game

  creats the board
  creates the screen,
  calls puzzle generator to create the first puzzle
  creates the blocks for that puzzle
  creates everything else if necessary
  starts the movement tick

  listens to cubed.
  if last Cube :deleted, game ends

end
